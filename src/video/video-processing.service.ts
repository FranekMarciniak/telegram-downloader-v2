import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import { join } from 'path';

const execAsync = promisify(exec);

@Injectable()
export class VideoProcessingService {
  private readonly logger = new Logger(VideoProcessingService.name);
  private readonly tempDir: string;

  constructor(private readonly configService: ConfigService) {
    this.tempDir = this.configService.get<string>(
      'app.tempDir',
      '/tmp/downloads',
    );
  }

  async splitFileIntoChunks(filePath: string): Promise<string[]> {
    const CHUNK_DURATION_SECONDS = 60; // 60 seconds
    const chunkFilenames: string[] = [];

    try {
      // Get video duration using ffprobe
      const probeCommand = `ffprobe -v quiet -show_entries format=duration -of csv=p=0 "${filePath}"`;
      const { stdout: durationOutput } = await execAsync(probeCommand);
      const videoDuration = parseFloat(durationOutput.trim());

      this.logger.debug(
        `Splitting video: ${filePath} (${videoDuration.toFixed(2)}s) into ${CHUNK_DURATION_SECONDS}s chunks using ffmpeg`,
      );

      // If video is shorter than chunk duration, no need to split
      if (videoDuration <= CHUNK_DURATION_SECONDS) {
        this.logger.debug(
          'Video is shorter than chunk duration, no splitting needed',
        );
        return [filePath];
      }

      // Generate output pattern for chunks
      const originalName = filePath.replace(/\.[^/.]+$/, ''); // Remove extension
      const extension = filePath.match(/\.[^/.]+$/)?.[0] || '.mp4';
      const outputPattern = `${originalName}_chunk_%03d${extension}`;

      // Use ffmpeg to split the video by time segments
      const ffmpegCommand = `ffmpeg -i "${filePath}" -c copy -f segment -segment_time ${CHUNK_DURATION_SECONDS} -reset_timestamps 1 "${outputPattern}"`;

      this.logger.debug(`Executing ffmpeg command: ${ffmpegCommand}`);

      const { stdout, stderr } = await execAsync(ffmpegCommand, {
        timeout: 300000, // 5 minutes timeout
        cwd: this.tempDir,
      });

      if (stdout) {
        this.logger.debug(`ffmpeg stdout: ${stdout}`);
      }

      if (stderr) {
        this.logger.debug(`ffmpeg stderr: ${stderr}`);
      }

      // Find all generated chunk files
      const files = await fs.readdir(this.tempDir);
      const basePattern = originalName.split('/').pop() || originalName; // Get just the filename part
      const chunkPattern = new RegExp(
        `${basePattern}_chunk_\\d{3}${extension.replace('.', '\\.')}`,
      );

      const generatedChunks = files
        .filter((file) => chunkPattern.test(file))
        .map((file) => join(this.tempDir, file))
        .sort(); // Sort to ensure proper order

      this.logger.debug(
        `Generated ${generatedChunks.length} chunks: ${generatedChunks.map((f) => f.split('/').pop()).join(', ')}`,
      );

      if (generatedChunks.length === 0) {
        throw new Error('No chunks were generated by ffmpeg');
      }

      // Verify all chunks exist and are readable
      for (const chunkPath of generatedChunks) {
        await fs.access(chunkPath, fs.constants.R_OK);
        const chunkStats = await fs.stat(chunkPath);
        this.logger.debug(
          `Chunk verified: ${chunkPath} (${(chunkStats.size / 1024 / 1024).toFixed(2)} MB)`,
        );
        chunkFilenames.push(chunkPath);
      }

      // Remove the original file after successful chunking
      await fs.unlink(filePath);
      this.logger.debug(`Removed original file: ${filePath}`);

      return chunkFilenames;
    } catch (error) {
      this.logger.error(
        `Failed to split video into chunks with ffmpeg: ${error.message}`,
      );
      throw new Error(`Video chunking failed: ${error.message}`);
    }
  }
}
